# 🔐 Генератор Мастер-Сида

Криптографически стойкий генератор мастер-сида для лотерейных систем. Объединяет множество сидов от разных устройств в один надежный мастер-сид.

## 📋 Содержание

-   [Быстрый старт](#-быстрый-старт)
-   [Как это работает](#-как-это-работает)
-   [Технические детали](#-технические-детали)
-   [Безопасность](#-безопасность)
-   [FAQ](#-faq)

---

## 🚀 Быстрый старт

### Вариант 1: Python (рекомендуется)

**Требования:** Python 3.7+

**Установка и запуск:**

```bash
# Установите зависимости (если нужны)
pip install passlib

# Запустите генератор
python master_seed_generator.py
```

**Использование:**

```
$ python master_seed_generator.py

=== Генератор Мастер-Сида ===

Введите сиды от устройств (по одному на строку).
Для завершения ввода оставьте строку пустой и нажмите Enter.

Сид #1: device-seed-alpha-1234567890
Сид #2: device-seed-beta-9876543210
Сид #3: device-seed-gamma-5555555555
Сид #4: [нажмите Enter]

✓ Получено сидов: 3

Мастер-сид (детерминированный):
a7f3e9c2b1d8f6e4a9c3b7d2e8f1a6c4b9d3e7f2a8c6b1d9e3f7a2c8b4d6e9f3a1

Длина: 64 символа (256 бит энтропии)
SHA-256 хеш: c3d4e5f6...
```

### Вариант 2: Go

**Требования:** Go 1.16+

**Установка и запуск:**

```bash
# Инициализируйте go
go mod init master-seed-generator

# Установите зависимости
go get golang.org/x/crypto/pbkdf2

# Запустите генератор
go run master_seed_generator.go
```

**Использование аналогично Python версии.**

---

## 🧠 Как это работает

### Простым языком

Представьте, что у вас есть несколько устройств (телефоны, компьютеры), и каждое генерирует свой уникальный код (сид). Чтобы провести честную лотерею, нужно объединить все эти коды в один "главный код" (мастер-сид), который:

1. ✅ **Невозможно предсказать** заранее
2. ✅ **Всегда одинаковый** при одинаковых входных данных
3. ✅ **Невозможно подделать** или изменить незаметно

### Процесс генерации

```
┌─────────────────────────────────────────────────────────────┐
│  Сиды от устройств                                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ Устройство 1 │  │ Устройство 2 │  │ Устройство 3 │     │
│  │ abc123xyz    │  │ def456uvw    │  │ ghi789rst    │     │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘     │
│         │                  │                  │              │
│         └──────────────────┼──────────────────┘              │
│                            ▼                                 │
│                   ┌────────────────┐                        │
│                   │  Сортировка    │                        │
│                   │  (алфавитный   │                        │
│                   │   порядок)     │                        │
│                   └────────┬───────┘                        │
│                            ▼                                 │
│                   ┌────────────────┐                        │
│                   │  Объединение   │                        │
│                   │  в одну строку │                        │
│                   └────────┬───────┘                        │
│                            ▼                                 │
│                   ┌────────────────┐                        │
│                   │  PBKDF2-SHA512 │                        │
│                   │  (100,000      │                        │
│                   │   итераций)    │                        │
│                   └────────┬───────┘                        │
│                            ▼                                 │
│                   ┌────────────────┐                        │
│                   │  Финальное     │                        │
│                   │  SHA-512       │                        │
│                   │  хэширование   │                        │
│                   └────────┬───────┘                        │
│                            ▼                                 │
│               ┌────────────────────────┐                    │
│               │  Мастер-сид (64 hex)   │                    │
│               │  a7f3e9c2b1d8f6e4...   │                    │
│               └────────────────────────┘                    │
└─────────────────────────────────────────────────────────────┘
```

### Пошаговое объяснение

**Шаг 1: Сортировка**

```
Входные сиды:
- "device-gamma-555"
- "device-alpha-123"
- "device-beta-987"

После сортировки:
- "device-alpha-123"
- "device-beta-987"
- "device-gamma-555"
```

Это обеспечивает **детерминированность** — порядок ввода не важен, результат всегда одинаковый.

**Шаг 2: Объединение**

```
"device-alpha-123device-beta-987device-gamma-555"
```

**Шаг 3: PBKDF2 (Password-Based Key Derivation Function 2)**

Это специальный алгоритм, который:

-   Берет объединенную строку
-   Добавляет фиксированную "соль" (`master-seed-salt-v1`)
-   Прогоняет через SHA-512 **100,000 раз** (это делает атаку перебором очень медленной)
-   Генерирует 64 байта (512 бит) данных

**Шаг 4: Финальное хэширование**

```
SHA-512(результат PBKDF2) → мастер-сид
```

Дополнительный слой защиты для максимальной диффузии (изменение одного бита входных данных меняет ~50% бит выходных).

---

## 🔬 Технические детали

### Алгоритм

```
MasterSeed = SHA512(PBKDF2-HMAC-SHA512(
    password = sort(seeds).join(),
    salt = "master-seed-salt-v1",
    iterations = 100000,
    keyLength = 64 bytes
))
```

### Параметры безопасности

| Параметр       | Значение           | Обоснование                           |
| -------------- | ------------------ | ------------------------------------- |
| Хэш-функция    | SHA-512            | 512 бит выхода, стойкость к коллизиям |
| KDF            | PBKDF2             | Стандарт NIST, широко протестирован   |
| Итерации       | 100,000            | Защита от brute-force (~100ms на хэш) |
| Соль           | Фиксированная      | Обеспечивает детерминированность      |
| Выходная длина | 64 байта (512 бит) | 2^512 возможных значений              |

### Почему детерминированный?

**Детерминированность** означает, что при одинаковых входных данных **всегда** получается одинаковый результат:

```python
# Пример 1
seeds = ["abc", "def", "ghi"]
master_seed_1 = generate("abc", "def", "ghi")
# → a7f3e9c2b1d8f6e4...

# Пример 2 (те же сиды, другой порядок)
master_seed_2 = generate("ghi", "abc", "def")
# → a7f3e9c2b1d8f6e4... (идентично!)

# Пример 3 (другие сиды)
master_seed_3 = generate("abc", "def", "xyz")
# → c8d4f1a9e3b7... (полностью другой!)
```

**Зачем это нужно?**

-   ✅ Прозрачность: любой может проверить результат
-   ✅ Аудируемость: результаты лотереи можно воспроизвести
-   ✅ Честность: никто не может изменить результат после сбора сидов

---

## 🛡️ Безопасность

### Что защищает алгоритм

✅ **Предсказание результата**
Без знания всех сидов невозможно предсказать мастер-сид. Изменение одного символа в одном сиде полностью меняет результат.

✅ **Подмена данных**
Злоумышленник не может незаметно изменить сиды — любое изменение даст другой мастер-сид.

✅ **Атаки перебором (brute-force)**
100,000 итераций PBKDF2 делают перебор крайне медленным (примерно 100мс на одну попытку).

✅ **Коллизии**
SHA-512 устойчив к коллизиям — практически невозможно найти два набора сидов с одинаковым мастер-сидом.

### Рекомендации по использованию

1. **Генерация сидов устройств**

    ```python
    import secrets
    device_seed = secrets.token_hex(32)  # 64 символа
    ```

2. **Минимальная длина сидов**: 16+ символов (чем длиннее, тем лучше)

3. **Количество устройств**: минимум 3 для максимальной децентрализации

4. **Хранение сидов**: каждое устройство хранит только свой сид

5. **Публикация**: мастер-сид можно публиковать открыто, исходные сиды — **никогда**

---

## 📊 Примеры использования

### Пример 1: Лотерея с 3 устройствами

```bash
$ python master_seed_generator.py

Сид #1: phone-5f8a3c2e1d9b7a4f6e3c8b1d5a9f2e7c
Сид #2: laptop-3c7b9a2f5e1d8c4a7b3f6e9d2c5a8b1f
Сид #3: server-9d2a7c5f1b8e4a3c6f9b2d5e8a1c7f4b
Сид #4:

Мастер-сид: f4e9c3a7b2d8f1e6a9c4b7d3e8f2a6c5b9d4e7f3a8c1b6d9e2f7a3c8b5d1e9f4
```

### Пример 2: Проверка детерминированности

```bash
# Первый запуск
$ python master_seed_generator.py
Сид #1: abc
Сид #2: def
Сид #3: ghi
Сид #4:
Мастер-сид: a7f3e9c2b1d8f6e4a9c3b7d2e8f1a6c4...

# Второй запуск (другой порядок)
$ python master_seed_generator.py
Сид #1: ghi
Сид #2: abc
Сид #3: def
Сид #4:
Мастер-сид: a7f3e9c2b1d8f6e4a9c3b7d2e8f1a6c4...
# ✓ Идентично первому!
```

### Пример 3: Использование в коде

**Python:**

```python
from master_seed_generator import generate_master_seed_deterministic

device_seeds = [
    "device-alpha-123",
    "device-beta-456",
    "device-gamma-789"
]

master_seed = generate_master_seed_deterministic(device_seeds)
print(f"Мастер-сид: {master_seed}")
```

**Go:**

```go
deviceSeeds := []string{
    "device-alpha-123",
    "device-beta-456",
    "device-gamma-789",
}

masterSeed, err := GenerateMasterSeedDeterministic(deviceSeeds)
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Мастер-сид: %s\n", masterSeed)
```

---

## ❓ FAQ

### Почему именно 100,000 итераций PBKDF2?

Это баланс между безопасностью и производительностью:

-   **Меньше итераций**: быстрее, но легче атаковать перебором
-   **Больше итераций**: медленнее для пользователя
-   **100,000**: ~100мс на современном процессоре, достаточно для защиты

### Можно ли использовать меньше 3 сидов?

Технически — да, но не рекомендуется:

-   **1 сид**: один человек контролирует результат
-   **2 сида**: возможен сговор
-   **3+ сида**: достаточная децентрализация

### Что если я потеряю один из сидов?

**Без всех сидов невозможно воспроизвести мастер-сид.** Поэтому:

-   Храните резервные копии каждого сида отдельно
-   Записывайте мастер-сид после генерации
-   Документируйте процесс генерации

### Нужно ли хранить исходные сиды после генерации?

**Да**, если нужна возможность проверки:

-   Для аудита результатов
-   Для подтверждения честности процесса
-   Для воспроизведения результата

Но публиковать их **не нужно** — достаточно мастер-сида.

### Можно ли использовать для чего-то кроме лотерей?

Да! Алгоритм подходит для любых задач, где нужен:

-   Детерминированный генератор случайных чисел
-   Объединение нескольких источников энтропии
-   Создание общего секрета из частей

---

## 📝 Лицензия

MIT License - используйте свободно в коммерческих и некоммерческих проектах.

---

## 🤝 Поддержка

Нашли баг? Есть предложения? Создайте issue в репозитории!

---

**Версия алгоритма:** v1.0

**Последнее обновление:** 2025

**Made by [davg](https://github.com/davg-team)**
